<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ output extension=".d.ts" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ Include File="T4TS.tt.settings.t4" #><#= 
    OutputFormatter.GetOutput(GetDataToRender(), GetSettings()) #><#+ 

Settings settings = null;
Settings GetSettings()
{
    if (settings== null)
        settings = Settings.Parse(SettingsValues);

    return settings;
}

List<TypeScriptModule> GetDataToRender() {
    DTE dte = null;

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null)
        dte = serviceProvider.GetService(typeof(SDTE)) as DTE;

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (dte == null)
        throw new Exception("Can only execute through the Visual Studio host");

    var project = GetProjectContainingT4File(dte);
        
    if (project == null)
        throw new Exception("Could not find the VS project containing the T4TS file.");

    var generator = new CodeTraverser(dte.Solution, GetSettings());
    return generator.GetAllInterfaces().ToList();
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
    // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
    // Note: this is certainly hacky, but is the best I could come up with so far.
    projectItem.Document.Saved = false;

    return projectItem.ContainingProject;
}

    public class EnumOutputAppender : OutputAppender<TypeScriptEnum>
    {
        public EnumOutputAppender(StringBuilder output, int baseIndentation, Settings settings)
            : base(output, baseIndentation, settings)
        {
        }

        public override void AppendOutput(TypeScriptEnum tsEnum)
        {
            BeginInterface(tsEnum);

            AppendMembers(tsEnum);

            EndInterface();
        }

        public void AppendOutputSubEnum(TypeScriptEnum tsEnum, TypeScriptInterface owner)
        {
            BeginInterface(tsEnum, owner);

            AppendMembers(tsEnum, owner);

            EndInterface(owner);
        }

        private void AppendMembers(TypeScriptEnum tsEnum, TypeScriptInterface owner = null)
        {
            int identation = 4;
            while (owner != null)
            {
                identation += 4;
                owner = owner.Owner;
            }
            var appender = new EnumMemberOutputAppender(Output, BaseIndentation + identation, Settings);
            foreach (TypeScriptEnumMember member in tsEnum.Members)
                appender.AppendOutput(member);
        }

        private void BeginInterface(TypeScriptEnum tsEnum, TypeScriptInterface owner = null)
        {
            AppendIndentedLine("/** Generated from " + tsEnum.FullName + " **/");
            if (owner == null)
            {
                AppendIndented("enum " + tsEnum.Name);
            }
            else
            {
                string module = owner.Name;
                string enumName = tsEnum.Name;
                string[] arr = tsEnum.Name.Split('.');
                if (arr.Length > 1)
                {
                    module = arr[0];
                    enumName = arr[1];
                }
                AppendIndentedLine("module " + module + " {");
                AppendIndendation();
                AppendIndented("enum " + enumName);
            }
            Output.AppendLine(" {");
        }

        private void EndInterface(TypeScriptInterface owner = null)
        {
            while (owner != null)
            {
                AppendIndendation();
                AppendIndentedLine("}");
                owner = owner.Owner;
            }
            AppendIndentedLine("}");
        }
    }

    public class EnumMemberOutputAppender : OutputAppender<TypeScriptEnumMember>
    {
        public EnumMemberOutputAppender(StringBuilder output, int baseIndentation, Settings settings)
            : base(output, baseIndentation, settings)
        {
        }

        public override void AppendOutput(TypeScriptEnumMember member)
        {
            AppendIndendation();

            Output.AppendFormat("{0} = {1}",
                member.Name,
                member.Value
                );

            Output.AppendLine(",");
        }
    }

    public abstract class OutputAppender<TSegment> where TSegment : class
    {
        public OutputAppender(StringBuilder output, int baseIndentation, Settings settings)
        {
            if (output == null)
                throw new ArgumentNullException("output");

            if (settings == null)
                throw new ArgumentNullException("settings");

            Output = output;
            BaseIndentation = baseIndentation;
            Settings = settings;
        }

        protected StringBuilder Output { get; private set; }
        protected int BaseIndentation { get; private set; }
        protected Settings Settings { get; private set; }

        public abstract void AppendOutput(TSegment segment);

        protected void AppendIndented(string text)
        {
            AppendIndendation();
            Output.Append(text);
        }

        protected void AppendIndentedLine(string line)
        {
            AppendIndendation();
            Output.AppendLine(line);
        }

        protected void AppendIndendation()
        {
            Output.Append(' ', BaseIndentation);
        }

        public override string ToString()
        {
            return Output.ToString();
        }
    }

    public class InterfaceOutputAppender : OutputAppender<TypeScriptInterface>
    {
        public InterfaceOutputAppender(StringBuilder output, int baseIndentation, Settings settings, bool inGlobalModule)
            : base(output, baseIndentation, settings)
        {
            InGlobalModule = inGlobalModule;
        }

        private bool InGlobalModule { get; set; }

        public override void AppendOutput(TypeScriptInterface tsInterface)
        {
            foreach (TypeScriptEnum tsSubEnum in tsInterface.SubEnums)
            {
                AppendOutputSubEnum(tsSubEnum, tsInterface);
            }

            foreach (TypeScriptInterface tsSubClass in tsInterface.SubClasses)
            {
                AppendOutputSubClass(tsSubClass, tsInterface);
            }

            BeginInterface(tsInterface);

            AppendMembers(tsInterface);

            if (tsInterface.IndexedType != null)
                AppendIndexer(tsInterface);

            EndInterface();
        }

        private void AppendOutputSubClass(TypeScriptInterface tsInterface, TypeScriptInterface owner)
        {
            BeginInterface(tsInterface, owner);

            foreach (TypeScriptInterface tsSubClass in tsInterface.SubClasses)
            {
                AppendOutput(tsSubClass);
            }

            AppendMembers(tsInterface, owner);

            if (tsInterface.IndexedType != null)
                AppendIndexer(tsInterface);

            EndInterface(owner);
        }

        private void AppendOutputSubEnum(TypeScriptEnum tsEnum, TypeScriptInterface owner)
        {
            var enumAppender = new EnumOutputAppender(Output, BaseIndentation, Settings);
            enumAppender.AppendOutputSubEnum(tsEnum, owner);
        }

        private void AppendMembers(TypeScriptInterface tsInterface, TypeScriptInterface owner = null)
        {
            int identation = 4;
            while (owner != null)
            {
                identation += 4;
                owner = owner.Owner;
            }
            var appender = new MemberOutputAppender(Output, BaseIndentation + identation, Settings);
            foreach (TypeScriptInterfaceMember member in tsInterface.Members)
                appender.AppendOutput(member);
        }

        private void BeginInterface(TypeScriptInterface tsInterface, TypeScriptInterface owner = null)
        {
            AppendIndentedLine("/** Generated from " + tsInterface.FullName + " **/");

            if (owner == null)
            {
                if (InGlobalModule)
                    AppendIndented("interface " + tsInterface.Name);
                else
                    AppendIndented("export interface " + tsInterface.Name);
            }
            else
            {
                string module = owner.Name;
                string interfaceName = tsInterface.Name;
                string[] arr = tsInterface.Name.Split('.');
                if (arr.Length > 1)
                {
                    module = arr[0];
                    interfaceName = arr[1];
                }
                AppendIndentedLine("module " + module + " {");
                AppendIndendation();
                AppendIndented("export interface " + interfaceName);
            }

            if (tsInterface.Parent != null)
                Output.Append(" extends " +
                              (tsInterface.Parent.Module.IsGlobal ? "" : tsInterface.Parent.Module.QualifiedName + ".") +
                              tsInterface.Parent.Name);

            Output.AppendLine(" {");
        }

        private void EndInterface(TypeScriptInterface owner = null)
        {
            while (owner != null)
            {
                AppendIndendation();
                AppendIndentedLine("}");
                owner = owner.Owner;
            }
            AppendIndentedLine("}");
        }

        private void AppendIndexer(TypeScriptInterface tsInterface)
        {
            AppendIndendation();
            Output.AppendFormat("    [index: number]: {0};", tsInterface.IndexedType);
            Output.AppendLine();
        }
    }

    public class MemberOutputAppender : OutputAppender<TypeScriptInterfaceMember>
    {
        public MemberOutputAppender(StringBuilder output, int baseIndentation, Settings settings)
            : base(output, baseIndentation, settings)
        {
        }

        public override void AppendOutput(TypeScriptInterfaceMember member)
        {
            AppendIndendation();

            bool isOptional = member.Optional || (member.Type is NullableType);
            string type = member.Type.ToString();

            if (member.Type is BoolType)
            {
                if (Settings.CompatibilityVersion != null && Settings.CompatibilityVersion < new Version(0, 9, 0))
                    type = "bool";
                else
                    type = "boolean";
            }

            Output.AppendFormat("{0}{1}: {2}",
                member.Name,
                (isOptional ? "?" : ""),
                type
                );

            Output.AppendLine(";");
        }
    }

    public class ModuleOutputAppender : OutputAppender<TypeScriptModule>
    {
        public ModuleOutputAppender(StringBuilder output, int baseIndentation, Settings settings)
            : base(output, baseIndentation, settings)
        {
        }

        public override void AppendOutput(TypeScriptModule module)
        {
            BeginModule(module);

            var enumAppender = new EnumOutputAppender(Output, BaseIndentation + 4, Settings);
            foreach (TypeScriptEnum tsEnum in module.Enums)
                enumAppender.AppendOutput(tsEnum);

            var interfaceAppender = new InterfaceOutputAppender(Output, BaseIndentation + 4, Settings, module.IsGlobal);
            foreach (TypeScriptInterface tsInterface in module.Interfaces)
                interfaceAppender.AppendOutput(tsInterface);

            EndModule(module);
        }

        private void BeginModule(TypeScriptModule module)
        {
            if (module.IsGlobal)
            {
                Output.AppendLine("// -- Begin global interfaces");
            }
            else
            {
                if (Settings.CompatibilityVersion != null && Settings.CompatibilityVersion < new Version(0, 9, 0))
                    Output.Append("module ");
                else
                    Output.Append("declare module ");

                Output.Append(module.QualifiedName);
                Output.AppendLine(" {");
            }
        }

        private void EndModule(TypeScriptModule module)
        {
            if (module.IsGlobal)
                Output.AppendLine("// -- End global interfaces");
            else
                Output.AppendLine("}");
        }
    }

    public static class OutputFormatter
    {
        public static string GetOutput(List<TypeScriptModule> modules, Settings settings)
        {
            var output = new StringBuilder();

            output.AppendLine("/****************************************************************************");
            output.AppendLine("  Generated by T4TS.tt - don't make any changes in this file");
            output.AppendLine("****************************************************************************/");

            var moduleAppender = new ModuleOutputAppender(output, 0, settings);
            foreach (TypeScriptModule module in modules)
            {
                output.AppendLine();
                moduleAppender.AppendOutput(module);
            }

            return output.ToString();
        }
    }

    public class TypeScriptEnum
    {
        public TypeScriptEnum()
        {
            Members = new List<TypeScriptEnumMember>();
        }

        public string Name { get; set; }
        public string FullName { get; set; }

        public List<TypeScriptEnumMember> Members { get; set; }
        public TypeScriptModule Module { get; set; }
        public TypeScriptInterface Owner { get; set; }
    }

    public class TypeScriptEnumAttributeValues
    {
        public string Module { get; set; }
        public string Name { get; set; }
        public string NamePrefix { get; set; }
    }

    public class TypeScriptInterfaceAttributeValues
    {
        public string Module { get; set; }
        public string Name { get; set; }
        public string NamePrefix { get; set; }
    }

    public class TypeScriptEnumMember
    {
        public string Name { get; set; }
        public string FullName { get; set; }
        public int Value { get; set; }
        public bool Ignore { get; set; }
    }

    public class TypeScriptMemberAttributeValues
    {
        public string Name { get; set; }
        public bool Optional { get; set; }
        public string Type { get; set; }
        public bool CamelCase { get; set; }
        public bool Ignore { get; set; }
    }

    public class CodeTraverser
    {
        private const string InterfaceAttributeFullName = "T4TS.TypeScriptInterfaceAttribute";
        private const string MemberAttributeFullName = "T4TS.TypeScriptMemberAttribute";
        private const string EnumAttributeFullName = "T4TS.TypeScriptEnumAttribute";

        public CodeTraverser(Solution solution, Settings settings)
        {
            if (solution == null)
                throw new ArgumentNullException("solution");

            if (settings == null)
                throw new ArgumentNullException("settings");

            Solution = solution;
            Settings = settings;
        }

        public Solution Solution { get; private set; }
        public static Settings Settings { get; private set; }


        private void BuildCodeClass(TypeContext typeContext, CodeClass codeClass, CodeClass owner = null)
        {
            if (codeClass == null) return;
            CodeAttribute attribute;
            InterfaceType interfaceType = null;
            if (owner != null)
            {
                TypescriptType tsType = typeContext.GetTypeScriptType(owner.FullName);
                if (tsType != null)
                    interfaceType = new InterfaceType(codeClass.Name);
            }
            if (TryGetAttribute(codeClass.Attributes, InterfaceAttributeFullName, out attribute))
            {
                TypeScriptInterfaceAttributeValues values = GetInterfaceValues(codeClass, attribute);
                interfaceType = new InterfaceType(values);
            }
            else if (Settings.ProcessDataContracts && TryGetAttribute(codeClass.Attributes, "System.Runtime.Serialization.DataContractAttribute", out attribute))
            {
                var values = new TypeScriptInterfaceAttributeValues()
                {
                    Name = codeClass.Name,
                    Module = Settings.DefaultModule ?? "T4TS",
                    NamePrefix = Settings.DefaultInterfaceNamePrefix ?? string.Empty
                };
                interfaceType = new InterfaceType(values);
            }
            if (interfaceType != null)
            {
                if (!typeContext.ContainsInterfaceType(codeClass.FullName))
                    typeContext.AddInterfaceType(codeClass.FullName, interfaceType);
                foreach (object subCodeClass in codeClass.Members)
                {
                    BuildCodeClass(typeContext, subCodeClass as CodeClass, codeClass);
                    BuildCodeEnum(typeContext, subCodeClass as CodeEnum, codeClass);
                }
            }
        }

        private void BuildCodeEnum(TypeContext typeContext, CodeEnum codeEnum, CodeClass owner = null)
        {
            if (codeEnum == null) return;
            CodeAttribute attribute;
            EnumType enumType = null;
            if (owner != null)
            {
                TypescriptType tsType = typeContext.GetTypeScriptType(owner.FullName);
                if (tsType != null)
                    enumType = new EnumType(codeEnum.Name);
            }
            if (TryGetAttribute(codeEnum.Attributes, EnumAttributeFullName, out attribute))
            {
                TypeScriptEnumAttributeValues values = GetEnumValues(codeEnum, attribute);
                enumType = new EnumType(values);
            }
            if (enumType != null)
            {
                if (!typeContext.ContainsEnumType(codeEnum.FullName))
                    typeContext.AddEnumType(codeEnum.FullName, enumType);
            }
        }

        public TypeContext BuildContext()
        {
            var typeContext = new TypeContext(Settings);

            new SolutionTraverser(Solution, ns =>
            {
                new NamespaceTraverser(ns,
                    codeClass => BuildCodeClass(typeContext, codeClass),
                    codeEnum => BuildCodeEnum(typeContext, codeEnum)
                    );
            });

            return typeContext;
        }

        private void ProcessCodeClass(TypeContext typeContext, IDictionary<CodeClass, TypeScriptInterface> tsMap,
            IDictionary<string, TypeScriptModule> byModuleName, CodeClass codeClass)
        {
            InterfaceType interfaceType;
            if (typeContext.TryGetInterfaceType(codeClass.FullName, out interfaceType))
            {
                TypeScriptInterfaceAttributeValues values = interfaceType.AttributeValues;

                TypeScriptModule module;
                if (!byModuleName.TryGetValue(values.Module, out module))
                {
                    module = new TypeScriptModule {QualifiedName = values.Module};
                    byModuleName.Add(values.Module, module);
                }

                TypeScriptInterface tsInterface = BuildInterface(codeClass, values, typeContext);
                tsMap.Add(codeClass, tsInterface);
                tsInterface.Module = module;
                module.Interfaces.Add(tsInterface);
            }
        }

        private void ProcessCodeEnum(TypeContext typeContext, IDictionary<CodeEnum, TypeScriptEnum> tsEnumMap,
            IDictionary<string, TypeScriptModule> byModuleName, CodeEnum codeEnum)
        {
            EnumType enumType;
            if (typeContext.TryGetEnumType(codeEnum.FullName, out enumType))
            {
                TypeScriptEnumAttributeValues values = enumType.AttributeValues;

                TypeScriptModule module;
                if (!byModuleName.TryGetValue(values.Module, out module))
                {
                    module = new TypeScriptModule {QualifiedName = values.Module};
                    byModuleName.Add(values.Module, module);
                }

                TypeScriptEnum tsEnum = BuildEnum(codeEnum, values, typeContext);
                tsEnumMap.Add(codeEnum, tsEnum);
                tsEnum.Module = module;
                module.Enums.Add(tsEnum);
            }
        }

        public IEnumerable<TypeScriptModule> GetAllInterfaces()
        {
            TypeContext typeContext = BuildContext();
            var byModuleName = new Dictionary<string, TypeScriptModule>();
            var tsMap = new Dictionary<CodeClass, TypeScriptInterface>();
            var tsEnumMap = new Dictionary<CodeEnum, TypeScriptEnum>();

            new SolutionTraverser(Solution, ns =>
            {
                new NamespaceTraverser(ns,
                    codeClass => ProcessCodeClass(typeContext, tsMap, byModuleName, codeClass),
                    codeEnum => ProcessCodeEnum(typeContext, tsEnumMap, byModuleName, codeEnum)
                    );
            });

            List<TypeScriptInterface> tsInterfaces = tsMap.Values.ToList();
            tsMap.Keys.ToList().ForEach(codeClass =>
            {
                CodeElements baseClasses = codeClass.Bases;
                if (baseClasses.Count > 0)
                {
                    CodeElement baseClass = baseClasses.Item(1);
                    if (baseClass != null)
                    {
                        TypeScriptInterface parent =
                            tsInterfaces.SingleOrDefault(intf => intf.FullName == baseClass.FullName);
                        if (parent != null)
                        {
                            tsMap[codeClass].Parent = parent;
                        }
                    }
                }
            });

            return byModuleName.Values
                .OrderBy(m => m.QualifiedName)
                .ToList();
        }

        private string GetInterfaceName(TypeScriptInterfaceAttributeValues attributeValues)
        {
            if (!string.IsNullOrEmpty(attributeValues.NamePrefix))
                return attributeValues.NamePrefix + attributeValues.Name;

            return attributeValues.Name;
        }

        private string GetEnumName(TypeScriptEnumAttributeValues attributeValues)
        {
            if (!string.IsNullOrEmpty(attributeValues.NamePrefix))
                return attributeValues.NamePrefix + attributeValues.Name;

            return attributeValues.Name;
        }

        private TypeScriptInterface BuildInterface(CodeClass codeClass,
            TypeScriptInterfaceAttributeValues attributeValues, TypeContext typeContext)
        {
            var tsInterface = new TypeScriptInterface
            {
                FullName = codeClass.FullName,
                Name = GetInterfaceName(attributeValues)
            };

            // Add sub-classes to the interface
            foreach (CodeClass codeSubClass in codeClass.Members.OfType<CodeClass>())
            {
                var subAttributeValues = new TypeScriptInterfaceAttributeValues {Name = codeSubClass.Name};
                InterfaceType interfaceType;
                if (typeContext.TryGetInterfaceType(codeSubClass.FullName, out interfaceType))
                {
                    subAttributeValues = interfaceType.AttributeValues;
                    subAttributeValues.Module = attributeValues.Module + "." + tsInterface.Name;
                }

                TypeScriptInterface subInterface = BuildInterface(codeSubClass, subAttributeValues, typeContext);
                subInterface.Owner = tsInterface;
                tsInterface.SubClasses.Add(subInterface);
            }

            // Add sub-enums to the interface
            foreach (CodeEnum codeSubEnum in codeClass.Members.OfType<CodeEnum>())
            {
                var subAttributeValues = new TypeScriptEnumAttributeValues {Name = codeSubEnum.Name};
                EnumType enumType;
                if (typeContext.TryGetEnumType(codeSubEnum.FullName, out enumType))
                {
                    subAttributeValues = enumType.AttributeValues;
                    subAttributeValues.Module = attributeValues.Module + "." + tsInterface.Name;
                }

                TypeScriptEnum subEnum = BuildEnum(codeSubEnum, subAttributeValues, typeContext);
                subEnum.Owner = tsInterface;
                tsInterface.SubEnums.Add(subEnum);
            }

            TypescriptType indexedType;
            if (TryGetIndexedType(codeClass, typeContext, out indexedType))
                tsInterface.IndexedType = indexedType;

            new ClassTraverser(codeClass, property =>
            {
                TypeScriptInterfaceMember member;
                if (TryGetMember(property, typeContext, out member))
                    tsInterface.Members.Add(member);
            });


            return tsInterface;
        }

        private TypeScriptEnum BuildEnum(CodeEnum codeEnum, TypeScriptEnumAttributeValues attributeValues,
            TypeContext typeContext)
        {
            var tsEnum = new TypeScriptEnum
            {
                FullName = codeEnum.FullName,
                Name = GetEnumName(attributeValues)
            };

            new EnumTraverser(codeEnum, (variable, index) =>
            {
                TypeScriptEnumMember member;
                if (TryGetEnumMember(variable, typeContext, index, out member))
                    tsEnum.Members.Add(member);
            });

            return tsEnum;
        }

        private bool TryGetAttribute(CodeElements attributes, string attributeFullName, out CodeAttribute attribute, bool useShortAttributeName = false)
        {
            foreach (CodeAttribute attr in attributes)
            {
                if ((useShortAttributeName ? attr.Name : attr.FullName) == attributeFullName)
                {
                    attribute = attr;
                    return true;
                }
            }

            attribute = null;
            return false;
        }

        private bool TryGetIndexedType(CodeClass codeClass, TypeContext typeContext, out TypescriptType indexedType)
        {
            indexedType = null;
            if (codeClass.Bases == null || codeClass.Bases.Count == 0)
                return false;

            foreach (CodeElement baseClass in codeClass.Bases)
            {
                if (TypeContext.IsGenericEnumerable(baseClass.FullName))
                {
                    string fullName = typeContext.UnwrapGenericType(baseClass.FullName);
                    indexedType = typeContext.GetTypeScriptType(fullName);
                    return true;
                }
            }

            return false;
        }

        private TypeScriptInterfaceAttributeValues GetInterfaceValues(CodeClass codeClass, CodeAttribute interfaceAttribute)
        {
            Dictionary<string, string> values = GetAttributeValues(interfaceAttribute);

            return new TypeScriptInterfaceAttributeValues
            {
                Name = values.ContainsKey("Name") ? values["Name"] : codeClass.Name,
                Module = values.ContainsKey("Module") ? values["Module"] : Settings.DefaultModule ?? "T4TS",
                NamePrefix = values.ContainsKey("NamePrefix")
                        ? values["NamePrefix"]
                        : Settings.DefaultInterfaceNamePrefix ?? string.Empty
            };
        }

        private TypeScriptEnumAttributeValues GetEnumValues(CodeEnum codeEnum, CodeAttribute interfaceAttribute)
        {
            Dictionary<string, string> values = GetAttributeValues(interfaceAttribute);

            return new TypeScriptEnumAttributeValues
            {
                Name = values.ContainsKey("Name") ? values["Name"] : codeEnum.Name,
                Module = values.ContainsKey("Module") ? values["Module"] : Settings.DefaultModule ?? "T4TS",
                NamePrefix =
                    values.ContainsKey("NamePrefix")
                        ? values["NamePrefix"]
                        : Settings.DefaultEnumNamePrefix ?? string.Empty
            };
        }

        private bool TryGetMember(CodeProperty property, TypeContext typeContext, out TypeScriptInterfaceMember member)
        {
            member = null;
            if (property.Access != vsCMAccess.vsCMAccessPublic)
                return false;

            CodeFunction getter = property.Getter;
            if (getter == null)
                return false;

            TypeScriptMemberAttributeValues values = GetMemberValues(property, typeContext);

            member = new TypeScriptInterfaceMember
            {
                Name = values.Name ?? property.Name,
                FullName = property.FullName,
                Optional = values.Optional,
                Ignore = values.Ignore,
                Type = (string.IsNullOrWhiteSpace(values.Type))
                    ? typeContext.GetTypeScriptType(getter.Type)
                    : new InterfaceType(values.Type)
            };

            if (member.Ignore)
            {
                return false;
            }

            if (values.CamelCase && values.Name == null)
                member.Name = member.Name.Substring(0, 1).ToLowerInvariant() + member.Name.Substring(1);

            return true;
        }

        private bool TryGetEnumMember(CodeVariable variable, TypeContext typeContext, int index,
            out TypeScriptEnumMember member)
        {
            member = null;
            if (variable.Access != vsCMAccess.vsCMAccessPublic)
                return false;

            TypeScriptMemberAttributeValues values = GetMemberValues(variable, typeContext);
            member = new TypeScriptEnumMember
            {
                Name = values.Name ?? variable.Name,
                FullName = variable.FullName,
                Ignore = values.Ignore,
                Value = variable.InitExpression == null ? index : Int32.Parse(variable.InitExpression.ToString()),
            };

            if (member.Ignore)
            {
                return false;
            }

            if (values.CamelCase && values.Name == null)
                member.Name = member.Name.Substring(0, 1).ToLowerInvariant() + member.Name.Substring(1);

            return true;
        }

        private TypeScriptMemberAttributeValues GetMemberValues(CodeProperty property, TypeContext typeContext)
        {
            bool? attributeOptional = null;
            bool? attributeCamelCase = null;
            bool attributeIgnore = false;
            string attributeName = null;
            string attributeType = null;

            CodeAttribute attribute;

            // By default ignore properties marked with JsonIgnoreAttribute
            if (TryGetAttribute(property.Attributes, "JsonIgnoreAttribute", out attribute, true))
            {
                attributeIgnore = true;
            }
            if (TryGetAttribute(property.Attributes, MemberAttributeFullName, out attribute))
            {
                Dictionary<string, string> values = GetAttributeValues(attribute);
                if (values.ContainsKey("Optional"))
                    attributeOptional = values["Optional"] == "true";

                if (values.ContainsKey("CamelCase"))
                    attributeCamelCase = values["CamelCase"] == "true";

                if (values.ContainsKey("Ignore"))
                    attributeIgnore = values["Ignore"] == "true";

                values.TryGetValue("Name", out attributeName);
                values.TryGetValue("Type", out attributeType);
            }

            return new TypeScriptMemberAttributeValues
            {
                Optional = attributeOptional.HasValue ? attributeOptional.Value : Settings.DefaultOptional,
                Name = attributeName,
                Type = attributeType,
                CamelCase = attributeCamelCase ?? Settings.DefaultCamelCaseMemberNames,
                Ignore = attributeIgnore
            };
        }

        private TypeScriptMemberAttributeValues GetMemberValues(CodeVariable variable, TypeContext typeContext)
        {
            bool? attributeOptional = null;
            bool? attributeCamelCase = null;
            bool attributeIgnore = false;
            string attributeName = null;
            string attributeType = null;

            CodeAttribute attribute;
            if (TryGetAttribute(variable.Attributes, MemberAttributeFullName, out attribute))
            {
                Dictionary<string, string> values = GetAttributeValues(attribute);
                if (values.ContainsKey("Optional"))
                    attributeOptional = values["Optional"] == "true";

                if (values.ContainsKey("CamelCase"))
                    attributeCamelCase = values["CamelCase"] == "true";

                if (values.ContainsKey("Ignore"))
                    attributeIgnore = values["Ignore"] == "true";

                values.TryGetValue("Name", out attributeName);
                values.TryGetValue("Type", out attributeType);
            }

            return new TypeScriptMemberAttributeValues
            {
                Optional = attributeOptional.HasValue ? attributeOptional.Value : Settings.DefaultOptional,
                Name = attributeName,
                Type = attributeType,
                CamelCase = attributeCamelCase ?? Settings.DefaultCamelCaseMemberNames,
                Ignore = attributeIgnore
            };
        }

        private Dictionary<string, string> GetAttributeValues(CodeAttribute codeAttribute)
        {
            var values = new Dictionary<string, string>();
            foreach (CodeElement child in codeAttribute.Children)
            {
                var property = (EnvDTE80.CodeAttributeArgument)child;
                if (property == null || property.Value == null)
                    continue;

                // remove quotes if the property is a string
                string val = property.Value ?? string.Empty;
                if (val.StartsWith("\"") && val.EndsWith("\""))
                    val = val.Substring(1, val.Length - 2);

                values.Add(property.Name, val);
            }

            return values;
        }
    }

    public class Settings
    {
        /// <summary>
        ///     The default module of the generated interface, if not specified by the TypeScriptInterfaceAttribute
        /// </summary>
        public string DefaultModule { get; set; }

        /// <summary>
        ///     The default value for Optional, if not specified by the TypeScriptMemberAttribute
        /// </summary>
        public bool DefaultOptional { get; set; }

        /// <summary>
        ///     The default value for the CamelCase flag for an interface member name, if not specified by the
        ///     TypeScriptMemberAttribute
        /// </summary>
        public bool DefaultCamelCaseMemberNames { get; set; }

        /// <summary>
        ///     The default string to prefix interface names with. For instance, you might want to prefix the names with an "I" to
        ///     get conventional interface names.
        /// </summary>
        public string DefaultInterfaceNamePrefix { get; set; }

        /// <summary>
        ///     The default string to prefix enum names with. For instance, you might want to prefix the names with an "E" to get
        ///     conventional enum names.
        /// </summary>
        public string DefaultEnumNamePrefix { get; set; }

        /// <summary>
        ///     The version of Typescript that is targeted
        /// </summary>
        public Version CompatibilityVersion { get; set; }

        /// <summary>
        ///     If true translates System.DateTime to native date
        /// </summary>
        public bool UseNativeDates { get; set; }

        /// <summary>
        ///     List of the project names to process. If null - all the projects will be processed.
        /// </summary>
        public string[] ProjectNamesToProcess { get; set; }

        /// <summary>
        ///     If equals <c>true</c> - classes marked with <see cref="DataContractAttribute"/> will be processed.
        /// </summary>
        public bool ProcessDataContracts { get; set; }

        public static Settings Parse(Dictionary<string, object> settingsValues)
        {
            // Read settings from T4TS.tt.settings.tt
            return new Settings
            {
                DefaultModule = ParseSettingReferenceType(settingsValues, "DefaultModule", s => s as string, "T4TS"),
                DefaultOptional = ParseSettingNullableType(settingsValues, "DefaultOptional", false),
                DefaultCamelCaseMemberNames = ParseSettingNullableType(settingsValues, "DefaultCamelCaseMemberNames", false),
                DefaultInterfaceNamePrefix = ParseSettingReferenceType(settingsValues, "DefaultInterfaceNamePrefix", s => s as string, string.Empty),
                CompatibilityVersion = ParseSettingReferenceType(settingsValues, "CompatibilityVersion", v => v as Version, new Version(0, 9, 1, 1)),
                UseNativeDates = ParseSettingNullableType(settingsValues, "UseNativeDates", false),
                ProjectNamesToProcess = ParseSettingReferenceType(settingsValues, "ProjectNamesToProcess", s => s == null ? null : s.ToString().Replace(" ", "").Split(','), null),
                ProcessDataContracts = ParseSettingNullableType(settingsValues, "ProcessDataContracts", false),
            };
        }

        private static T ParseSettingReferenceType<T>(Dictionary<string, object> settingsValues, string key,
            Func<object, T> convert, T defaultValue) where T : class
        {
            object val;
            if (settingsValues.TryGetValue(key, out val))
                return convert(val) ?? defaultValue;

            return defaultValue;
        }

        private static T ParseSettingNullableType<T>(Dictionary<string, object> settingsValues, string key,
            T defaultValue) where T : struct
        {
            object val;
            if (settingsValues.TryGetValue(key, out val))
            {
                var nullable = val as T?;
                if (nullable == null || !nullable.HasValue)
                    return defaultValue;

                return nullable.Value;
            }

            return defaultValue;
        }

        private static T ParseConfigValueType<T>(Dictionary<string, object> settingsValues, string key,
            Func<object, T> convert, T defaultValue)
        {
            object val;
            if (settingsValues.TryGetValue(key, out val))
                return convert(val);

            return defaultValue;
        }
    }

    public class EnumTraverser
    {
        public EnumTraverser(CodeEnum codeEnum, Action<CodeVariable, int> withVariable)
        {
            if (codeEnum == null) throw new ArgumentNullException("codeEnum");

            if (withVariable == null) throw new ArgumentNullException("withVariable");

            CodeEnum = codeEnum;
            WithVariable = withVariable;

            if (codeEnum.Members != null)
                Traverse(codeEnum.Members);
        }

        public CodeEnum CodeEnum { get; private set; }
        public Action<CodeVariable, int> WithVariable { get; set; }

        private void Traverse(CodeElements members)
        {
            int index = 0;
            foreach (CodeVariable property in members.OfType<CodeVariable>())
            {
                WithVariable(property, index);
                if (property.InitExpression != null)
                    index = Int32.Parse(property.InitExpression.ToString());
                index++;
            }
        }
    }

    public class ClassTraverser
    {
        public ClassTraverser(CodeClass codeClass, Action<CodeProperty> withProperty)
        {
            if (codeClass == null) throw new ArgumentNullException("codeClass");
            if (withProperty == null) throw new ArgumentNullException("withProperty");

            CodeClass = codeClass;
            WithProperty = withProperty;

            if (codeClass.Members != null)
                Traverse(codeClass.Members);
        }

        public CodeClass CodeClass { get; private set; }
        public Action<CodeProperty> WithProperty { get; private set; }

        private void Traverse(CodeElements members)
        {
            foreach (CodeProperty property in members.OfType<CodeProperty>())
                WithProperty(property);
        }
    }

    public class NamespaceTraverser
    {
        public NamespaceTraverser(CodeNamespace ns, Action<CodeClass> withCodeClass, Action<CodeEnum> withCodeEnum)
        {
            if (ns == null)
                throw new ArgumentNullException("ns");

            if (withCodeClass == null)
                throw new ArgumentNullException("withCodeClass");

            WithCodeClass = withCodeClass;

            WithCodeEnum = withCodeEnum;

            if (ns.Members != null)
                Traverse(ns.Members);
        }

        public Action<CodeClass> WithCodeClass { get; private set; }
        public Action<CodeEnum> WithCodeEnum { get; private set; }

        private void Traverse(CodeElements members)
        {
            foreach (CodeEnum codeEnum in members.OfType<CodeEnum>())
                WithCodeEnum(codeEnum);
            foreach (CodeClass codeClass in members.OfType<CodeClass>())
                WithCodeClass(codeClass);
        }
    }

    public class ProjectTraverser
    {
        public ProjectTraverser(Project project, Action<CodeNamespace> withNamespace)
        {
            if (project == null)
                throw new ArgumentNullException("project");

            if (withNamespace == null)
                throw new ArgumentNullException("withNamespace");

            WithNamespace = withNamespace;

            if (project.ProjectItems != null)
                Traverse(project.ProjectItems);
        }

        public Action<CodeNamespace> WithNamespace { get; private set; }

        private void Traverse(ProjectItems items)
        {
            foreach (ProjectItem pi in items)
            {
                if (pi.FileCodeModel != null)
                {
                    if (CodeTraverser.Settings.ProjectNamesToProcess == null ||
                        CodeTraverser.Settings.ProjectNamesToProcess.Contains(pi.ContainingProject.Name))
                    {
                        CodeElements codeElements = pi.FileCodeModel.CodeElements;
                        foreach (CodeNamespace ns in codeElements.OfType<CodeNamespace>())
                            WithNamespace(ns);
                    }
                }

                if (pi.ProjectItems != null)
                    Traverse(pi.ProjectItems);

                    /* LionSoft: Process projects in solution folders */
                else if (pi.SubProject != null && pi.SubProject.ProjectItems != null)
                {
                    Traverse(pi.SubProject.ProjectItems);
                }
                /* --- */
            }
        }
    }

    public class TypeScriptModule
    {
        public TypeScriptModule()
        {
            Interfaces = new List<TypeScriptInterface>();
            Enums = new List<TypeScriptEnum>();
        }

        public string QualifiedName { get; set; }
        public List<TypeScriptInterface> Interfaces { get; set; }
        public List<TypeScriptEnum> Enums { get; set; }

        /// <summary>
        ///     Returns true if this is the global namespace (ie. no module name)
        /// </summary>
        public bool IsGlobal
        {
            get { return string.IsNullOrWhiteSpace(QualifiedName); }
        }
    }

    public class SolutionTraverser
    {
        public SolutionTraverser(Solution solution, Action<CodeNamespace> withNamespace)
        {
            if (solution == null)
                throw new ArgumentNullException("solution");

            if (withNamespace == null)
                throw new ArgumentNullException("withNamespace");

            WithNamespace = withNamespace;

            if (solution.Projects != null)
                Traverse(solution.Projects);
        }

        public Action<CodeNamespace> WithNamespace { get; private set; }

        private void Traverse(Projects projects)
        {
            foreach (Project project in projects)
            {
                new ProjectTraverser(project, WithNamespace);
            }
        }
    }

    public class ArrayType : TypescriptType
    {
        public TypescriptType ElementType { get; set; }

        public override string ToString()
        {
            return ElementType + "[]";
        }
    }

    public class BoolType : TypescriptType
    {
        public override string Name
        {
            get { return "boolean"; }
        }
    }

    public class EnumType : TypescriptType
    {
        public EnumType(TypeScriptEnumAttributeValues values)
        {
            AttributeValues = values;
        }

        public EnumType(string name)
        {
            AttributeValues = new TypeScriptEnumAttributeValues
            {
                Name = name
            };
        }

        public TypeScriptEnumAttributeValues AttributeValues { get; private set; }

        public string QualifedModule
        {
            get
            {
                if (AttributeValues == null)
                    return null;

                return AttributeValues.Module;
            }
        }

        public override string Name
        {
            get
            {
                if (!string.IsNullOrEmpty(AttributeValues.NamePrefix))
                    return AttributeValues.NamePrefix + AttributeValues.Name;

                return AttributeValues.Name;
            }
        }

        public override string ToString()
        {
            if (string.IsNullOrWhiteSpace(QualifedModule))
                return base.ToString();

            return QualifedModule + "." + base.ToString();
        }
    }

    public class InterfaceType : TypescriptType
    {
        public InterfaceType(TypeScriptInterfaceAttributeValues values)
        {
            AttributeValues = values;
        }

        public InterfaceType(string name)
        {
            AttributeValues = new TypeScriptInterfaceAttributeValues
            {
                Name = name
            };
        }

        public TypeScriptInterfaceAttributeValues AttributeValues { get; private set; }

        public string QualifedModule
        {
            get
            {
                if (AttributeValues == null)
                    return null;

                return AttributeValues.Module;
            }
        }

        public override string Name
        {
            get
            {
                if (!string.IsNullOrEmpty(AttributeValues.NamePrefix))
                    return AttributeValues.NamePrefix + AttributeValues.Name;

                return AttributeValues.Name;
            }
        }

        public override string ToString()
        {
            if (string.IsNullOrWhiteSpace(QualifedModule))
                return base.ToString();

            return QualifedModule + "." + base.ToString();
        }
    }

    public class NullableType : TypescriptType
    {
        public TypescriptType WrappedType { get; set; }

        public override string ToString()
        {
            return WrappedType.ToString();
        }
    }

    public class NumberType : TypescriptType
    {
        public override string Name
        {
            get { return "number"; }
        }
    }

    public class DateTimeType : TypescriptType
    {
        public override string Name
        {
            get { return "Date"; }
        }
    }

    public class StringType : TypescriptType
    {
        public override string Name
        {
            get { return "string"; }
        }
    }

    public class TypeContext
    {
        private const string NullableTypeStart = "System.Nullable<";

        private static readonly string[] _genericCollectionTypeStarts =
        {
            "System.Collections.Generic.List<",
            "System.Collections.Generic.IList<",
            "System.Collections.Generic.ICollection<"
        };

        private readonly Dictionary<string, EnumType> _enumTypes = new Dictionary<string, EnumType>();

        /// <summary>
        ///     Lookup table for "interface types", ie. non-builtin types (typically classes or unknown types). Keyed on the
        ///     FullName of the type.
        /// </summary>
        private readonly Dictionary<string, InterfaceType> _interfaceTypes = new Dictionary<string, InterfaceType>();

        public TypeContext(Settings settings)
        {
            Settings = settings;
        }

        public Settings Settings { get; private set; }

        public void AddInterfaceType(string typeFullName, InterfaceType interfaceType)
        {
            _interfaceTypes.Add(typeFullName, interfaceType);
        }

        public void AddEnumType(string typeFullName, EnumType enumType)
        {
            _enumTypes.Add(typeFullName, enumType);
        }

        public bool TryGetInterfaceType(string typeFullName, out InterfaceType interfaceType)
        {
            return _interfaceTypes.TryGetValue(typeFullName, out interfaceType);
        }

        public bool TryGetEnumType(string typeFullName, out EnumType enumType)
        {
            return _enumTypes.TryGetValue(typeFullName, out enumType);
        }

        public bool ContainsInterfaceType(string typeFullName)
        {
            return _interfaceTypes.ContainsKey(typeFullName);
        }

        public bool ContainsEnumType(string typeFullName)
        {
            return _enumTypes.ContainsKey(typeFullName);
        }

        public TypescriptType GetTypeScriptType(CodeTypeRef codeType)
        {
            switch (codeType.TypeKind)
            {
                case vsCMTypeRef.vsCMTypeRefChar:
                case vsCMTypeRef.vsCMTypeRefString:
                    return new StringType();

                case vsCMTypeRef.vsCMTypeRefBool:
                    return new BoolType();

                case vsCMTypeRef.vsCMTypeRefByte:
                case vsCMTypeRef.vsCMTypeRefDouble:
                case vsCMTypeRef.vsCMTypeRefInt:
                case vsCMTypeRef.vsCMTypeRefShort:
                case vsCMTypeRef.vsCMTypeRefFloat:
                case vsCMTypeRef.vsCMTypeRefLong:
                case vsCMTypeRef.vsCMTypeRefDecimal:
                    return new NumberType();

                default:
                    return TryResolveType(codeType);
            }
        }

        private TypescriptType TryResolveType(CodeTypeRef codeType)
        {
            if (codeType.TypeKind == vsCMTypeRef.vsCMTypeRefArray)
            {
                return new ArrayType
                {
                    ElementType = GetTypeScriptType(codeType.ElementType)
                };
            }

            return GetTypeScriptType(codeType.AsFullName);
        }

        public TypescriptType GetTypeScriptType(string typeFullName)
        {
            InterfaceType interfaceType;
            if (_interfaceTypes.TryGetValue(typeFullName, out interfaceType))
                return interfaceType;

            EnumType enumType;
            if (_enumTypes.TryGetValue(typeFullName, out enumType))
                return enumType;

            if (IsGenericEnumerable(typeFullName))
            {
                return new ArrayType
                {
                    ElementType = GetTypeScriptType(UnwrapGenericType(typeFullName))
                };
            }
            if (IsNullable(typeFullName))
            {
                return new NullableType
                {
                    WrappedType = GetTypeScriptType(UnwrapGenericType(typeFullName))
                };
            }

            switch (typeFullName)
            {
                case "System.Guid":
                    return new GuidType();

                case "System.Double":
                case "System.Int16":
                case "System.Int32":
                case "System.Int64":
                case "System.UInt16":
                case "System.UInt32":
                case "System.UInt64":
                case "System.Decimal":
                case "System.Byte":
                case "System.SByte":
                case "System.Single":
                    return new NumberType();

                case "System.String":
                    return new StringType();

                case "System.DateTime":
                    if (Settings.UseNativeDates)
                        return new DateTimeType();
                    return new StringType();

                case "System.Boolean":
                    return new BoolType();

                default:
                    return new TypescriptType();
            }
        }

        private bool IsNullable(string typeFullName)
        {
            return typeFullName.StartsWith(NullableTypeStart);
        }

        public string UnwrapGenericType(string typeFullName)
        {
            int firstIndex = typeFullName.IndexOf('<');
            return typeFullName.Substring(firstIndex + 1, typeFullName.Length - firstIndex - 2);
        }

        public static bool IsGenericEnumerable(string typeFullName)
        {
            return _genericCollectionTypeStarts.Any(typeFullName.StartsWith);
        }
    }

    public class TypeScriptInterface
    {
        public TypeScriptInterface()
        {
            Members = new List<TypeScriptInterfaceMember>();
            SubClasses = new List<TypeScriptInterface>();
            SubEnums = new List<TypeScriptEnum>();
        }

        public string Name { get; set; }
        public string FullName { get; set; }

        public List<TypeScriptInterfaceMember> Members { get; set; }
        public TypescriptType IndexedType { get; set; }
        public TypeScriptInterface Parent { get; set; }
        public TypeScriptModule Module { get; set; }
        public TypeScriptInterface Owner { get; set; }


        public List<TypeScriptInterface> SubClasses { get; set; }
        public List<TypeScriptEnum> SubEnums { get; set; }
    }

    public class TypeScriptInterfaceMember
    {
        public string Name { get; set; }
        public TypescriptType Type { get; set; }
        public bool Optional { get; set; }
        public string FullName { get; set; }
        public bool Ignore { get; set; }
    }

    public class GuidType : TypescriptType
    {
        public override string Name
        {
            get { return "string"; }
        }
    }

    public class TypescriptType
    {
        public virtual string Name
        {
            get { return "any"; }
        }

        public override string ToString()
        {
            return Name;
        }
    }

#>