<#@ template language="C#" debug="false" hostspecific="true" #>
<#@ output extension=".d.ts" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0"#>
<#@ assembly name="EnvDTE"#>
<#@ assembly name="EnvDTE80"#>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="EnvDTE" #>
/****************************************************************************
  Generated by T4TS.tt - don't make any changes in this file
****************************************************************************/
<# foreach(var module in GetDataToRender()) { #>

<#= module.IsGlobal ? "// -- Begin global interfaces" : "module "+module.QualifiedName + " {" #>
<# foreach(var tsInterface in module.Interfaces) { #>
<#= module.IsGlobal? "" : "    " #>/** Generated from <#= tsInterface.FullName #> **/
<#= module.IsGlobal? "" : "    " #><#= module.IsGlobal?"":"export "#>interface <#= tsInterface.Name #> <#= tsInterface.Parent != null ? "extends "  + (tsInterface.Parent.Module.IsGlobal ? "/* global interface */" : tsInterface.Parent.Module.QualifiedName + ".") + tsInterface.Parent.Name : "" #> {
<# foreach(var member in tsInterface.Members) { #>
    <#= module.IsGlobal? "" : "    " #><#= member.Name + (member.Optional ? "?" : "") #>: <#=member.Type #>;
<# } #>
<# if (tsInterface.IndexedType != null) { #>
    <#= module.IsGlobal? "" : "    " #>[index: number]: <#= tsInterface.IndexedType #>;
<# } #>
<#= module.IsGlobal? "" : "    " #>}
<# } #>
<#= module.IsGlobal ? "// -- End global interfaces" : "}" #>
<# } #>
<#@ Include File="T4TS.tt.settings.t4"#>
<#+
List<TypeScriptModule> GetDataToRender() {
    DTE dte = null;

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null)
        dte = serviceProvider.GetService(typeof(SDTE)) as DTE;

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (dte == null)
        throw new Exception("Can only execute through the Visual Studio host");

    var project = GetProjectContainingT4File(dte);
        
    if (project == null)
        throw new Exception("Could not find the VS project containing the T4TS file.");

    // Read settings from T4TS.tt.settings.tt
    var settings = new Settings
    {
        DefaultModule = DefaultModule,
        DefaultOptional = DefaultOptional
    };

    var generator = new CodeGenerator(project, settings);

    return generator.GetAllInterfaces().ToList();
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
    // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
    // Note: this is certainly hacky, but is the best I could come up with so far.
    projectItem.Document.Saved = false;

    return projectItem.ContainingProject;
}

// -- Models ----------------------------------------------------------------------------------

class Settings
{
    /// <summary>
    /// The default module of the generated interface, if not specified by the TypeScriptInterfaceAttribute
    /// </summary>
    public string DefaultModule { get; set; }

    /// <summary>
    /// The default value for Optional, if not specified by the TypeScriptMemberAttribute
    /// </summary>
    public bool DefaultOptional { get; set; }
}
class TypeScriptInterface
{
    public string Name { get; set; }
    public string FullName { get; set; }

    public List<TypeScriptInterfaceMember> Members { get; set; }
    public TypescriptType IndexedType { get; set; }
    public TypeScriptInterface Parent { get; set; }
    public TypeScriptModule Module { get; set; }

    public TypeScriptInterface()
    {
        Members = new List<TypeScriptInterfaceMember>();
    }
}
class TypeScriptInterfaceAttributeValues
{
    public string Module { get; set; }
    public string Name { get; set; }
}
class TypeScriptInterfaceMember
{
    public string Name { get; set; }
    public TypescriptType Type { get; set; }
    public bool Optional { get; set; }
    public string FullName { get; set; }
}
class TypeScriptMemberAttributeValues
{
    public string Name { get; set; }
    public bool Optional { get; set; }
    public string Type { get; set; }
}
class TypeScriptModule
{
    public string QualifiedName { get; set; }
    public List<TypeScriptInterface> Interfaces { get; set; }
    public bool IsGlobal
    {
        get { return string.IsNullOrWhiteSpace(QualifiedName); }
    }

    public TypeScriptModule()
    {
        Interfaces = new List<TypeScriptInterface>();
    }
}

// -- Traversal ----------------------------------------------------------------------------------

class ClassTraverser
{
    public CodeClass CodeClass { get; private set; }
    public Action<CodeProperty> WithProperty { get; set; }

    public ClassTraverser(CodeClass codeClass, Action<CodeProperty> withProperty)
    {
        if (codeClass == null)
            throw new ArgumentNullException("codeClass");
            
        if (withProperty == null)
            throw new ArgumentNullException("withProperty");

        this.CodeClass = codeClass;
        this.WithProperty = withProperty;

        if (codeClass.Members != null)
            Traverse(codeClass.Members);
    }

    private void Traverse(CodeElements members)
    {
        foreach (var property in members.OfType<CodeProperty>())
            WithProperty(property);
    }
}
class NamespaceTraverser
{
    public Action<CodeClass> WithCodeClass { get; private set; }

    public NamespaceTraverser(CodeNamespace ns, Action<CodeClass> withCodeClass)
    {
        if (ns == null)
            throw new ArgumentNullException("ns");
            
        if (withCodeClass == null)
            throw new ArgumentNullException("withCodeClass");
            
        WithCodeClass = withCodeClass;
            
        if (ns.Members != null)
            Traverse(ns.Members);
    }

    private void Traverse(CodeElements members)
    {
        foreach (var codeClass in members.OfType<CodeClass>())
            WithCodeClass(codeClass);
    }
}
class ProjectTraverser
{
    public Action<CodeNamespace> WithNamespace { get; private set; }

    public ProjectTraverser(Project project, Action<CodeNamespace> withNamespace)
    {
        if (project == null)
            throw new ArgumentNullException("project");
            
        if (withNamespace == null)
            throw new ArgumentNullException("withNamespace");

        WithNamespace = withNamespace;

        if (project.ProjectItems != null)
            Traverse(project.ProjectItems);
    }

    private void Traverse(ProjectItems items)
    {
        foreach (ProjectItem pi in items)
        {
            if (pi.FileCodeModel != null)
            {
                var codeElements = pi.FileCodeModel.CodeElements;
                foreach (var ns in codeElements.OfType<CodeNamespace>())
                    WithNamespace(ns);
            }

            if (pi.ProjectItems != null)
                Traverse(pi.ProjectItems);
        }
    }
}

// -- Types ----------------------------------------------------------------------------------

class TypescriptType
{
    public virtual string Name { get { return "any"; } }

    public override string ToString()
    {
        return Name;
    }
}
class StringType: TypescriptType
{
    public override string Name
    {
        get { return "string"; }
    }
}
class NumberType : TypescriptType
{
    public override string Name
    {
        get { return "number"; }
    }
}
class BoolType: TypescriptType
{
    public override string Name
    {
        get { return "bool"; }
    }
}
class ArrayType: TypescriptType
{
    public TypescriptType ElementType { get; set; }

    public override string ToString()
    {
        return ElementType.ToString() + "[]";
    }
}
class CustomType: TypescriptType
{
    private string m_name;

    public override string Name
    {
        get { return m_name; }
    }
        
    public string QualifedModule { get; private set; }

    public CustomType(string name, string qualifiedModule=null)
    {
        m_name = name;
        this.QualifedModule = qualifiedModule;
    }

    public override string ToString()
    {
        if (string.IsNullOrWhiteSpace(QualifedModule))
            return base.ToString();

        return QualifedModule + "." + base.ToString();
    }
}
class TypeContext
{
    private static readonly string[] genericCollectionTypeStarts = new string[] {
        "System.Collections.Generic.List<",
        "System.Collections.Generic.IList<",
        "System.Collections.Generic.ICollection<"
    };

    /// <summary>
    /// Lookup table for "custom types", ie. non-builtin types. Keyed on the FullName of the type.
    /// </summary>
    private Dictionary<string, CustomType> customTypes = new Dictionary<string, CustomType>();

    public void AddCustomType(string typeFullName, CustomType customType)
    {
        customTypes.Add(typeFullName, customType);
    }

    public bool TryGetCustomType(string typeFullName, out CustomType customType)
    {
        return customTypes.TryGetValue(typeFullName, out customType);
    }

    public TypescriptType GetTypeScriptType(CodeTypeRef codeType)
    {
        switch (codeType.TypeKind)
        {
            case vsCMTypeRef.vsCMTypeRefChar:
            case vsCMTypeRef.vsCMTypeRefString:
                return new StringType();

            case vsCMTypeRef.vsCMTypeRefBool:
                return new BoolType();

            case vsCMTypeRef.vsCMTypeRefByte:
            case vsCMTypeRef.vsCMTypeRefDouble:
            case vsCMTypeRef.vsCMTypeRefInt:
            case vsCMTypeRef.vsCMTypeRefShort:
            case vsCMTypeRef.vsCMTypeRefFloat:
            case vsCMTypeRef.vsCMTypeRefLong:
            case vsCMTypeRef.vsCMTypeRefDecimal:
                return new NumberType();

            default:
                return TryResolveType(codeType);
        }
    }

    private TypescriptType TryResolveType(CodeTypeRef codeType)
    {
        if (codeType.TypeKind == vsCMTypeRef.vsCMTypeRefArray)
        {
            return new ArrayType()
            {
                ElementType = GetTypeScriptType(codeType.ElementType)
            };
        }

        return GetTypeScriptType(codeType.AsFullName);
    }

    private ArrayType TryResolveEnumerableType(string typeFullName)
    {
        return new ArrayType
        {
            ElementType = GetTypeScriptType(typeFullName)
        };
    }

    public TypescriptType GetTypeScriptType(string typeFullName)
    {
        CustomType customType;
        if (customTypes.TryGetValue(typeFullName, out customType))
            return customType;

        if (IsGenericEnumerable(typeFullName))
        {
            return new ArrayType
            {
                ElementType = GetTypeScriptType(UnwrapGenericType(typeFullName))
            };
        }

        switch (typeFullName)
        {
            case "System.Double":
            case "System.Int16":
            case "System.Int32":
            case "System.Int64":
            case "System.UInt16":
            case "System.UInt32":
            case "System.UInt64":
            case "System.Decimal":
            case "System.Byte":
            case "System.SByte":
            case "System.Single":
                return new NumberType();

            case "System.String":
            case "System.DateTime":
                return new StringType();

            default:
                return new TypescriptType();
        }
    }

    public string UnwrapGenericType(string typeFullName)
    {
        int firstIndex = typeFullName.IndexOf('<');
        return typeFullName.Substring(firstIndex+1, typeFullName.Length - firstIndex- 2);
    }

    public bool IsGenericEnumerable(string typeFullName)
    {
        return genericCollectionTypeStarts.Any(t => typeFullName.StartsWith(t));
    }
}

// -- Code generation --------------------------------------------------------------------------

class CodeGenerator
{
    public Project Project { get; private set; }
    public Settings Settings { get; private set; }

    private static readonly string InterfaceAttributeFullName = "T4TS.TypeScriptInterfaceAttribute";
    private static readonly string MemberAttributeFullName = "T4TS.TypeScriptMemberAttribute";

    public CodeGenerator(Project project, Settings settings)
    {
        if (project == null)
            throw new ArgumentNullException("project");

        if (settings == null)
            throw new ArgumentNullException("settings");

        this.Project = project;
        this.Settings = settings;
    }

    public TypeContext BuildContext()
    {
        var typeContext = new TypeContext();

        new ProjectTraverser(this.Project, (ns) =>
        {
            new NamespaceTraverser(ns, (codeClass) =>
            {
                CodeAttribute attribute;
                if (!TryGetAttribute(codeClass.Attributes, InterfaceAttributeFullName, out attribute))
                    return;

                var values = GetInterfaceValues(codeClass, attribute);
                var customType = new CustomType(values.Name, values.Module);

                typeContext.AddCustomType(codeClass.FullName, customType);
            });
        });

        return typeContext;
    }

    public IEnumerable<TypeScriptModule> GetAllInterfaces()
    {
        var typeContext = BuildContext();
        var byModuleName = new Dictionary<string, TypeScriptModule>();
		var tsMap = new Dictionary<CodeClass, TypeScriptInterface>();

        new ProjectTraverser(this.Project, (ns) =>
        {
            new NamespaceTraverser(ns, (codeClass) =>
            {
                if (codeClass.Attributes == null || codeClass.Attributes.Count == 0)
                    return;

                CodeAttribute attribute;
                if (!TryGetAttribute(codeClass.Attributes, InterfaceAttributeFullName, out attribute))
                    return;

                var values = GetInterfaceValues(codeClass, attribute);

                TypeScriptModule module;
                if (!byModuleName.TryGetValue(values.Module, out module))
                {
                    module = new TypeScriptModule { QualifiedName = values.Module };
                    byModuleName.Add(values.Module, module);
                }

                var tsInterface = BuildInterface(codeClass, values, typeContext);
                tsMap.Add(codeClass, tsInterface);
                tsInterface.Module = module;
                module.Interfaces.Add(tsInterface);
            });
        });

		var tsInterfaces = tsMap.Values.ToList();
		tsMap.Keys.ToList().ForEach(codeClass =>
		{
			var parent = tsInterfaces.LastOrDefault(intf => codeClass.IsDerivedFrom[intf.FullName] && intf.FullName != codeClass.FullName);
			if (parent != null)
				tsMap[codeClass].Parent = parent;
		});

        return byModuleName.Values
            .OrderBy(m => m.QualifiedName)
            .ToList();
    }

    private TypeScriptInterface BuildInterface(CodeClass codeClass, TypeScriptInterfaceAttributeValues attributeValues, TypeContext typeContext)
    {
        var tsInterface = new TypeScriptInterface
        {
            FullName = codeClass.FullName,
            Name = attributeValues.Name
        };

        TypescriptType indexedType;
        if (TryGetIndexedType(codeClass, typeContext, out indexedType))
            tsInterface.IndexedType = indexedType;

        new ClassTraverser(codeClass, (property) =>
        {
            TypeScriptInterfaceMember member;
            if (TryGetMember(property, typeContext, out member))
                tsInterface.Members.Add(member);
        });
        return tsInterface;
    }

    private bool TryGetAttribute(CodeElements attributes, string attributeFullName, out CodeAttribute attribute)
    {
        foreach (CodeAttribute attr in attributes)
        {
            if (attr.FullName == attributeFullName)
            {
                attribute = attr;
                return true;
            }
        }

        attribute = null;
        return false;
    }

    private bool TryGetIndexedType(CodeClass codeClass, TypeContext typeContext, out TypescriptType indexedType)
    {
        indexedType = null;
        if (codeClass.Bases == null || codeClass.Bases.Count == 0)
            return false;

        foreach (CodeElement baseClass in codeClass.Bases)
        {
            if (typeContext.IsGenericEnumerable(baseClass.FullName))
            {
                string fullName = typeContext.UnwrapGenericType(baseClass.FullName);
                indexedType = typeContext.GetTypeScriptType(fullName);
                return true;
            }
        }

        return false;
    }

    private TypeScriptInterfaceAttributeValues GetInterfaceValues(CodeClass codeClass, CodeAttribute interfaceAttribute)
    {
        var values = GetAttributeValues(interfaceAttribute);

        return new TypeScriptInterfaceAttributeValues
        {
            Name = values.ContainsKey("Name") ? values["Name"] : codeClass.Name,
            Module = values.ContainsKey("Module") ? values["Module"] : Settings.DefaultModule ?? "T4TS",
        };
    }

    private bool TryGetMember(CodeProperty property, TypeContext typeContext, out TypeScriptInterfaceMember member)
    {
        member = null;
        if (property.Access != vsCMAccess.vsCMAccessPublic)
            return false;

        var getter = property.Getter;
        if (getter == null)
            return false;

        var values = GetMemberValues(property, typeContext);
        member = new TypeScriptInterfaceMember
        {
            Name = values.Name ?? property.Name,
            FullName = property.FullName,
            Optional = values.Optional,
            Type = (string.IsNullOrWhiteSpace(values.Type))
                ? typeContext.GetTypeScriptType(getter.Type)
                : new CustomType(values.Type)
        };

        return true;
    }

    private TypeScriptMemberAttributeValues GetMemberValues(CodeProperty property, TypeContext typeContext)
    {
        bool? attributeOptional = null;
        string attributeName = null;
        string attributeType = null;

        CodeAttribute attribute;
        if (TryGetAttribute(property.Attributes, MemberAttributeFullName, out attribute))
        {
            var values = GetAttributeValues(attribute);
            if (values.ContainsKey("Optional"))
                attributeOptional = values["Optional"] == "true";

            values.TryGetValue("Name", out attributeName);
            values.TryGetValue("Type", out attributeType);
        }

        return new TypeScriptMemberAttributeValues
        {
            Optional = attributeOptional.HasValue ? attributeOptional.Value : Settings.DefaultOptional,
            Name = attributeName,
            Type = attributeType
        };
    }

    private Dictionary<string, string> GetAttributeValues(CodeAttribute codeAttribute)
    {
        var values = new Dictionary<string, string>();
        foreach (CodeElement child in codeAttribute.Children)
        {
            var property = (EnvDTE80.CodeAttributeArgument)child;
            if (property == null || property.Value == null)
                continue;
                
            // remove quotes if the property is a string
            string val = property.Value ?? string.Empty;
            if (val.StartsWith("\"") && val.EndsWith("\""))
                val = val.Substring(1, val.Length - 2);

            values.Add(property.Name, val);
        }

        return values;
    }
}
#>